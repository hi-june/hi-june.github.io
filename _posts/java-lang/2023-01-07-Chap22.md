---
title:  "[윤성우의 열혈 Java 프로그래밍] Chapter 22 - 제네릭(Generics) 2"
excerpt: "Java 문법 정리!"

categories:
  - Java lang
tags:
  - java

toc: true
toc_sticky: true

date: 2023-01-07
last_modified_at: 2023-02-15
---
## 22-1. 제네릭의 심화 문법
### - <u>제네릭 클래스와 상속</u>
제네릭 클래스도 다음과 같이 상속이 가능하다.  
```java
class Box<T> {
    protected T object;

    public void setObject(T object) {
        this.object = object;
    }

    public T getObject() {
        return object;
    }
}

class SteelBox<T> extends Box<T> {
    public SteelBox(T object) { // 제네릭 클래스의 생성자
        this.object = object;
    }
}

public class GenericInheritance {
    public static void main(String[] args) {
        Box<Integer> iBox = new SteelBox<>(8000);
        Box<String> sBox = new SteelBox<>("Simple");

        System.out.println(iBox.getObject());
        System.out.println(sBox.getObject());
    }
}
```
![image](/assets/images/java-lang/22-1.png){: width="40%" height="40%"}<br><br>
![image](/assets/images/java-lang/22-3.png){: width="60%" height="60%"}<br>
> SteelBox\<Integer\> 클래스는 Box\<Integer\> 클래스를 상속한다.  
> SteelBox\<Integer\> 제네릭 타입은 Box\<Integer\> 제네릭 타입을 상속한다.  

상속 관계 파악을 잘 해야 한다.  
```java
Box<Number> box = new Box<Integer>();   // 컴파일 가능할까?
```
뭔가 `Number`를 `Integer`가 상속하니까 위의 코드도 가능할 것 같지만,  
Box\<Number\>와 Box\<Integer\>는 상속 관계를 형성하지 않는다.  


### - <u>타겟 타입(Target Types)</u>
```java
class Box<T> {
    protected T object;

    public void setObject(T object) {
        this.object = object;
    }

    public T getObject() {
        return object;
    }
}

class EmptyBoxFactory {
    public static <T> Box<T> makeBox() {
        Box<T> box = new Box<>();
        return box;
    }
}

public class TargetTypes {
    public static void main(String[] args) {
        Box<Integer> iBox7 = EmptyBoxFactory.<Integer>makeBox();    // java 7 이전 문법
        Box<Integer> iBox8 = EmptyBoxFactory.makeBox(); // java 7부터 가능해짐

        iBox7.setObject(7);
        iBox8.setObject(8);

        System.out.println(iBox7.getObject());
        System.out.println(iBox8.getObject());
    }
}
```
![image](/assets/images/java-lang/22-2.png){: width="40%" height="40%"}<br>

위의 코드에서 makeBox 메소드는 인자를 전달받지 않는다.  
따라서, 원래는 T에 대한 타입 인자를 전달해주어야한다.  
하지만 자바 7부터는 컴파일러의 자료형 유추 범위가 넓어졌기 때문에 위와 같이 호출하는 것이 가능해졌다.

```java
Box<Integer> iBox8 = EmptyBoxFactory.makeBox(); // java 7부터 가능해짐
```
컴파일러는 위 문장을 보면서 makeBox 메소드는 Box\<Integer\> 인스턴스의 참조 값을 반환해야 한다고 판단한다.  
그리고 이 때, T의 유추에 사용된 정보 Box\<Integer\>를 가리켜 '타겟 타입'이라 한다.


### - <u>와일드카드(Wildcard)</u>
### - <u>와일드카드의 상한과 하한의 제한: Bounded Wildcards</u>
### - <u>언제 와일드 카드에 제한을 걸어야 하는가?: 도입</u>
### - <u>언제 와일드 카드에 제한을 걸어야 하는가?: 상한 제한의 목적</u>
### - <u>언제 와일드 카드에 제한을 걸어야 하는가?: 하한 제한의 목적</u>
### - <u>언제 와일드 카드에 제한을 걸어야 하는가?: 정리하기</u>
### - <u>제한된 와일드카드 선언을 갖는 제네릭 메소드</u>
### - <u>제네릭 인터페이스의 정의와 구현</u>