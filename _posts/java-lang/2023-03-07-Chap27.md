---
title:  "[윤성우의 열혈 Java 프로그래밍] Chapter 27 - 람다와 함수형 인터페이스"
excerpt: "Java 문법 정리!"

categories:
  - Java lang
tags:
  - java

toc: true
toc_sticky: true

date: 2023-03-07
last_modified_at: 2023-03-07
---
## 27-1. 람다와 함수형 인터페이스
### - <u>인스턴스보다 기능 하나가 필요한 상황을 위한 람다</u>
> 기능 하나를 정의해서 전달해야 하는 상황  

자바는 객체지향언어이기 때문에 인스턴스를 전달하는 형태이지만 내용을 보면 메소드, 즉 기능을 전달하는 상황이 생기곤 한다.  
이러한 상황에서 람다가 유용하게 쓰일 수 있다.  


### - <u>매개변수가 있고 반환하지 않는 람다식</u>
```java
interface LambdaExample {
    void print(String s);
}

public class OneParamNoReturn {
    public static void main(String[] args) {
        LambdaExample l;

        // 줄임 없는 표현
        l = (String s) -> { System.out.println(s); };

        // 중괄호 생략
        l = (String s) -> System.out.println(s);

        // 매개변수 형 생략
        l = (s) -> System.out.println(s);

        // 매개변수 소괄호 생략
        l = s -> System.out.println(s);

        l.print("Lambda example!");
    }
}
```

```java
interface Calculate {
    void cal(int a, int b);
}

public class TwoParamNoReturn {
    public static void main(String[] args) {
        Calculate c;    // 매개변수가 둘 이상인 경우, 괄호를 생략하는 것은 불가능하다.

        // 덧셈 진행
        c = (a, b) -> System.out.println(a + b);
        c.cal(4, 3);

        // 뺄셈 진행
        c = (a, b) -> System.out.println(a - b);
        c.cal(4,3);

        // 곱셈 진행
        c = (a, b) -> System.out.println(a * b);
        c.cal(4, 3);
    }
}
```


### - <u>매개변수가 있고 반환하는 람다식</u>
```java
interface RCalculate {
    int cal(int a, int b);
}

public class TwoParamAndReturn {
    public static void main(String[] args) {
        RCalculate c;

        // 몸체에 return이 들어가면 중괄호 생략 불가
        c = (a, b) -> { return a + b; };    // c = (a, b) -> { a + b; }; 불가능
        System.out.println(c.cal(4,3));

        // return 문이 메소드의 몸체를 이루는 유일한 경우
        c = (a, b) -> a + b;
        System.out.println(c.cal(4,3));
    }
}
```


### - <u>매개변수가 없는 람다식</u>
```java
import java.util.Random;

interface Generator {
    int rand(); // 매개변수 없는 메소드
}

public class NoParamAndReturn {
    public static void main(String[] args) {
        Generator g;

        g = () -> {
            Random random = new Random();
            return random.nextInt(50);
        };

        System.out.println(g.rand());
    }
}
```


### - <u>함수형 인터페이스와 어노테이션</u>
> 함수형 인터페이스: 추상 메소드가 딱 하나만 존재하는 인터페이스  

@FunctionsalInterface 어노테이션 타입을 통해 함수형 인터페이스에 부합하는지를 확인할 수 있다.  
인터페이스에 둘 이상의 추상 메소드가 존재하면, 컴파일 오류로 이어진다.  
그러나 static, default 선언이 붙은 메소드의 정의는 함수형 인터페이스의 정의에 아무런 영향을 미치지 않는다.  

```java
@FunctionalInterface
interface Calculate {
    int cal(int a, int b);
    default int add(int a, int b) { return a + b; }
    static int sub(int a, int b) { return a - b; }
}
```


### - <u>람다식과 제네릭</u>
인터페이스는 제네릭으로 정의하는 것이 가능하다.  
따라서 제네릭으로 정의된 함수형 인터페이스를 대상으로 람다식을 작성할 수도 있다.  

```java
@FunctionalInterface
interface Calculator <T> {
    T cal(T a, T b);
}

public class LambdaGeneric {
    public static void main(String[] args) {
        // 참조변수의 형을 지정해서 문장을 구성하면 된다.
        Calculator<Integer> intCalculator = (a, b) -> a + b;
        System.out.println(intCalculator.cal(3, 4));

        Calculator<Double> doubleCalculator = (a, b) -> a + b;
        System.out.println(doubleCalculator.cal(4.32, 3.45));
    }
}
```


## 27-2. 정의되어 있는 함수형 인터페이스


