---
title:  "[윤성우의 열혈 Java 프로그래밍] Chapter 23 - 컬렉션 프레임워크 1"
excerpt: "Java 문법 정리!"

categories:
  - Java lang
tags:
  - java

toc: true
toc_sticky: true

date: 2023-01-08
last_modified_at: 2023-02-02
---
## 23-1. 컬렉션 프레임워크의 이해
> 인스턴스의 저장과 삭제, 참조에 대한 문법

### - <u>'프레임워크'라는 표현의 이해</u>
자바에서 말하는 프레임워크는 다음과 같이 이해할 수 있다.  
> 잘 정의된 구조의 클래스들

즉, 프로그래머들이 쓸 수 있도록 잘 정의된 클래스들의 모임이라 할 수 있다.  
다만, 컬렉션 관련된 클래스의 정의에 적용되는 설계 원칙 또는 구조가 존재하기 때문에  
단순히 '컬렉션 라이브러리'라 하지 않고, '컬렉션 프레임워크'라고 한다.  


### - <u>컬렉션의 의미와 자료구조</u>
컬렉션 프레임워크는 데이터의 저장 방법, 그리고 이와 관련있는 알고리즘에 대한 프레임워크이다.  
즉, 자료구조와 알고리즘을 제네릭 기반의 클래스와 메소드로 미리 구현해 놓은 결과물이라 할 수 있다.  
따라서 컬렉션 프레임워크를 이용하면 자료구조를 몰라도 트리 기반으로 데이터를 저장할 수 있고,  
알고리즘을 몰라도 이진 탐색을 수행할 수 있는 것이다.


### - <u>컬렉션 프레임워크의 기본 골격</u>
![image](/assets/images/java-lang/23-1.jpeg)<br>

컬렉션 클래스들이 구현하는 인터페이스들의 상속 관계를 보여주고 있다.  
인스턴스를 저장하는 컬렉션 클래스들은 위의 인터페이스 중 하나를 구현하게 되어 있으며, 구현한 인터페이스에 따라서 컬렉션 클래스의 데이터 저장 방식이 결정된다.


## 23-2. List<E> 인터페이스를 구현하는 컬렉션 클래스들
### - <u>ArrayList, LinkedList</u>
`List` 인터페이스를 구현하는 대표적인 컬렉션 클래스 둘은 다음과 같다.  
- `ArrayList`: 배열 기반 자료구조, 배열을 이용하여 인스턴스 저장
- `LinkedList`: 리스트 기반 자료구조, 리스트를 구성하여 인스턴스 저장

<br>

`List` 인터페이스를 구현하는 컬렉션 클래스들은 공통적으로 다음 두 가지 특성을 가진다.  
1. 인스턴스의 저장 순서를 유지한다.
2. 동일하 인스턴스의 중복 저장을 허용한다.

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ListCollection {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        //List<String> list = new LinkedList<>();

        // 컬렉션 인스턴스에 문자열 인스턴스 저장
        list.add("Toy");
        list.add("Box");
        list.add("Robot");

        // 저장된 문자열 인스턴스의 참조
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i) + '\t');
        }
        System.out.println();

        list.remove(0); // 첫 번째 인스턴스 삭제

        // 첫 번째 인스턴스 삭제 후 나머지 인스턴스들을 참조
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i) + '\t');
        }
        System.out.println();
    }
}
```

코드에 유연성을 제공하기 위해 위와 같이 List형 참조변수를 사용하는 것이 더 적절하다.  
주로 `List`에 선언된 메소드를 호출하기 때문에 굳이 `ArrayList`형 참조변수를 선언할 필요가 없으며,  
다음과 같이 컬렉션 클래스의 교체가 용이해진다.  
```java
List<String> list = new ArrayList<>();
    -> List<String> list = new LinkedList<>();
```


### - <u>ArrayList vs LinkedList</u>
- `ArrayList`
    - 장점
        - 저장된 인스턴스의 참조가 빠르다.
    - 단점
        - 저장공간을 늘리는 과정에서 시간이 많이 소요된다.
        - 인스턴스의 삭제 연산에서 많은 연산이 필요하다. 따라서 속도가 느리다.

- `LinkedList`
    - 장점
        - 저장공간을 늘리는 과정이 간단하다.
        - 저장된 인스턴스의 삭제 과정이 단순하다.
    - 단점
        - 저장된 인스턴스의 참조과정이 배열에 비해 복잡하다. 따라서 속도가 느리다.


### - <u>저장된 인스턴스의 순차적 접근 방법 1: enhanced for문의 사용</u>
다음과 같이 enhanced for문을 사용하여 저장된 인스턴스들에 순차적으로 접근이 가능하다.  

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class EnhancedForCollection {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        //List<String> list = new LinkedList<>();

        // 컬렉션 인스턴스에 문자열 인스턴스 저장
        list.add("Toy");
        list.add("Box");
        list.add("Robot");

        // 저장된 문자열 인스턴스의 참조
        for (String s : list) {
            System.out.println(s + '\t');
        }
        System.out.println();

        list.remove(0); // 첫 번째 인스턴스 삭제

        // 첫 번째 인스턴스 삭제 후 나머지 인스턴스들을 참조
        for (String s : list) {
            System.out.println(s + '\t');
        }
        System.out.println();
    }
}
```
<br>
for-each문을 통한 순차적 접근의 대상이 되려면, 해당 컬렉션 클래스는 다음 인터페이스를 구현해야 한다.  
```java
public interface Iterable<T>
```

`Collection`이 `Iterable`을 상속하기 때문에  
`LinkedList`와 `ArrayList` 클래스는 for-each문 사용이 가능하다.


### - <u>저장된 인스턴스의 순차적 접근 방법 2</u>
`Iterable`에는 다음 추상 메소드가 있다.  
```java
Iterable<T> iterator()  // 반복자를 반환하는 메소드
```

반복자란,  
저장된 인스턴스들을 순차적으로 참조할 때 사용하는 인스턴스로 일종의 '지팡이'에 비유할 수 있다.  
그리고 이 반복자를 통해 호출할 수 있는 메소들을은 다음과 같다.  
```java
E next()            // 다음 인스턴스의 참조 값을 반환
boolean hasNext()   // next 메소드 호출 시 참조 값 반환 가능 여부 확인
void remove()       // next 메소드 호출을 통해 반환했던 인스턴스 삭제
```

```java
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class IteratorCollection {
    public static void main(String[] args) {
        List<String> list = new LinkedList<>();

        list.add("Toy");
        list.add("Box");
        list.add("Robot");
        list.add("Box");

        Iterator itr = list.iterator(); // 반복자 처음 획득

        // 반복자를 이용한 순차적 참조
        while (itr.hasNext()) {
            System.out.println(itr.next() + "\t");
        }
        System.out.println();

        itr = list.iterator();  // 반복자 다시 획득

        // 모든 "Box" 삭제
        while (itr.hasNext()) {
            if (itr.next().equals("Box")) {
                itr.remove();
            }
        }

        itr = list.iterator(); // 반복자 다시 획득

        // 삭제 후 결과 확인
        while (itr.hasNext()) {
            System.out.println(itr.next() + "\t");
        }
        System.out.println();
    }
}
```

### - <u>배열보다는 컬렉션 인스턴스가 좋다. : 컬렉션 변환</u>
첫 번째로 인스턴스의 저장과 삭제가 편하다.  
두 번째로 '반복자'를 쓸 수 있다.  

단, 배열처럼 '선언과 동시에 초기화'를 할 수 없어서 다음과 같은 방법을 써준다.  
```java
// 인자로 전달된 인스턴스들을 저장한 컬렉션 인스턴스의 생성 및 반환
List<String> list = new Arrays.asList("Toy", "Robot", "Box");
```

하지만 이렇게 생성된 컬렉션 인스턴스는 immutable하다.  
따라서 새로운 인스턴스의 추가나 삭제가 필요한 상황이라면 다음 생성자를 기반으로 ArrayList 인스턴스를 생성해야 한다.  


- public ArrayList(Collection<? extends E> c)  
    -> Collection을 구현한 컬렉션 인스턴스를 인자로 전달받는다.  
    -> 그리고 E는 인스턴스 생성 과정에서 결정되므로 무엇이든 될 수 있다.  
    -> 덧붙여서 매개변수 c로 전달된 컬렉션 인스턴스에서는 참조만(꺼내기만) 가능하다.  

```java
public static void main(String[] args) {
    List<String> list = Arrays.asList("Toy", "Box", "Robot");
    list = new ArrayList<>(list);   // 생성자
}
```


## 23-3. Set<E> 인터페이스를 구현하는 컬렉션 클래스들
### - <u>Set을 구현하는 클래스의 특성과 HashSet 클래스</u>
Set 인터페이스를 구현하는 제네릭 클래스는 다음 두 가지 특징이 있다.  
1) 저장 순서가 유지되지 않는다.  
2) 데이터의 중복 저장을 허용하지 않는다.  

```java
import java.util.HashSet;

class Num {
    private int num;
    public Num(int n) { num = n; }

    @Override
    public String toString() {
        return String.valueOf(num);
    }
}

public class HashSetEqualityOne {
    HashSet<Num> set = new HashSet<>();

    set.add(new Num(7799));
    set.add(new Num(9955));
    set.add(new Num(7799)); // 같은 인스턴스일 것이라고 기대

    System.out.println("인스턴스 수: " + set.size());   // 3 -> 중복 무시가 안 됨

    for (Num n : set)
        System.out.println(n.toString());
}
```

같은 인스턴스일 것이라고 기대하고 중복이 제거되어 `Set`에 들어갈 것이라 예상했지만, 모든 인스턴스가 들어갔다.  
`HashSet`이 판단하는 동일 인스턴스의 기준은 `Object` 클래스에 정의되어 있는 다음 두 메소드의 호출 결과를 근거로 한다.  

```java
public boolean equals(Object obj)
public int hashCode()
```

두 인스턴스가 `hashCode` 메소드 호출 결과로 반환하는 값이 동일해야 한다.  
그리고 이어서 두 인스턴스를 대상으로 `equals` 메소드의 호출 결과 true가 반환되면 동일 인스턴스로 간주한다.


### - <u>해쉬 알고리즘과 hashCode 메소드</u>
`Set`은 들어오는 데이터가 기존에 있는 데이터인지 검사해야한다.  
모든 데이터와 비교연산을 하기엔 데이터가 많아질 수록 성능적으로 좋지 않기 때문에 데이터들을 어느정도 분류해놓으면 탐색 시간을 획기적으로 줄일 수 있다.  

![image](/assets/images/java-lang/23-2.png){: width="50%" height="50%"}<br>

만약 특정 데이터의 존재 여부를 확인하려면 가장 효율적인 방법은 그 데이터가 속하는 부류를 먼저 찾고, 그 안에서만 비교연산을 하는 것이다.  
이로써 탐색 대상이 줄어들게 된다.

이처럼 `HashSet`에서 동일 인스턴스의 존재 여부를 확인하는 것은 다음 두 단계를 거친다.  
1) `Object` 클래스에 정의된 `hashCode` 메소드의 반환 값을 기반으로 부류 결정  
2) 선택된 부류 내에서 `equals` 메소드를 호출하여 동등 비교  

다시 돌아와서, 사용자가 직접 정의한 클래스의 인스턴스가 동일한지 기준을 정하기 위해 `hashCode`와 `equals` 메소드를 오버라이딩하여 정의해보자.  
```java
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

class Num {
    private int num;
    public Num(int n) {
        num = n;
    }

    @Override
    public String toString() {
        return String.valueOf(num);
    }

    @Override
    public int hashCode() {
        return num % 3;
    }

    @Override
    public boolean equals(Object o) {
        return num == ((Num)o).num;
    }
}

public class HashSetEqualityTwo {
    public static void main(String[] args) {
        Set<Num> set = new HashSet<>();

        set.add(new Num(4444));
        set.add(new Num(5555));
        set.add(new Num(4444));

        for (Iterator<Num> itr = set.iterator(); itr.hasNext();) {
            System.out.println(itr.next());
        }
    }
}
```


### - <u>hashCode 메소드의 다양한 정의</u>
`hashCode`를 정의할 땐 데이터들의 특성을 모두 반영하여 작성해야한다.  
즉, 클래스를 정의할 때마다 hashCode를 정의하는 것은 꽤 번거로운 일이다.  
그래서 자바에서는 다음 메소드를 제공하고 있다.  

```java
// java.util.Objects에 정의된 메소드, 전달된 인자 기반의 해쉬 값 반환
// java.lang.Object가 아니다. 헷갈리니 주의하자.
public static int hash(Object...values) 
```

```java
@Override
public int hashCode() {
    return Objects.hash(model, color);  // 전달 인자 model, color 기반 해쉬 값 반환
}
```


### - <u>TreeSet 클래스의 이해와 활용</u>
### - <u></u>
### - <u></u>
### - <u></u>


## 23-4. Queue<E> 인터페이스를 구현하는 컬렉션 클래스들
### - <u></u>
### - <u></u>
### - <u></u>


## 23-5. Map<K, V> 인터페이스를 구현하는 컬렉션 클래스들
### - <u></u>
### - <u></u>
### - <u></u>