<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-08T20:13:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html"> June &amp;amp; Directory </title><subtitle>공부 &amp; 취미 블로그</subtitle><author><name>hi~ June!!</name></author><entry><title type="html">[윤성우의 열혈 Java 프로그래밍] Chapter 34 - 쓰레드 그리고 동기화</title><link href="http://localhost:4000/java%20lang/Chap34/" rel="alternate" type="text/html" title="[윤성우의 열혈 Java 프로그래밍] Chapter 34 - 쓰레드 그리고 동기화" /><published>2023-06-08T00:00:00+09:00</published><updated>2023-06-08T00:00:00+09:00</updated><id>http://localhost:4000/java%20lang/Chap34</id><content type="html" xml:base="http://localhost:4000/java%20lang/Chap34/"><![CDATA[<h2 id="34-1-쓰레드의-이해와-쓰레드의-생성">34-1. 쓰레드의 이해와 쓰레드의 생성</h2>

<h3 id="--쓰레드의-이해와-쓰레드의-생성-방법">- <u>쓰레드의 이해와 쓰레드의 생성 방법</u></h3>

<blockquote>
  <p>실행중인 프로그램(프로세스) 내에서 ‘또 다른 실행의 흐름을 형성하는 주체’를 의미한다.</p>
</blockquote>

<p><img src="/assets/images/java-lang/34-1.png" alt="image" width="50%" height="50%" /><br />
<img src="/assets/images/java-lang/34-2.png" alt="image" width="30%" height="30%" /><br /></p>

<h3 id="--쓰레드를-생성하는-방법">- <u>쓰레드를 생성하는 방법</u></h3>

<p>코드 레벨에서 쓰레드는 생성하는 과정은 다음과 같다.</p>

<p><img src="/assets/images/java-lang/34-3.png" alt="image" width="50%" height="50%" /><br /></p>

<p>코드를 보면서 좀 더 알아보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MakeThreadDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Runnable을 구현한 인스턴스 생성</span>
        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>

            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="o">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">));</span>
        <span class="o">};</span>

        <span class="c1">// Thread 인스턴스 생성</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>

        <span class="c1">// start 메소드 호출 == Thread 생성 및 실행</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"End "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 실행 결과</span>
End main
Thread-0: 30
</code></pre></div></div>

<p>main 쓰레드가 먼저 종료된 것을 볼 수 있다. 쓰레드의 생성에는 시간이 걸리므로 충분히 가능한 상황이다.</p>

<p>모든 쓰레드가 일을 마치고 소멸되어야 프로그램이 종료된다.</p>

<p>또, 위와 같이 생성된 쓰레드는 자신의 일을 마치면 자동으로 소멸(쓰레드의 생성을 위해 할당했던 모든 자원의 해제)된다.</p>

<blockquote>
  <p>쓰레드는 자신의 일을 마치면(run 메소드의 실행을 완료하면) 자동으로 소멸된다.</p>
</blockquote>

<p>보통은 쓰레드 하나에 CUP의 코어 하나가 할당되어 동시에 실행이 이뤄진다.</p>

<p>여러 쓰레드가 실행되는 경우에는 이들은 코어를 나누어 차지하며 실행을 이어 나간다. 다만, 나누는 시간의 조각이 매우 작기 때문에 동시에 실행되는 효과를 충분히 누릴 수 있는 것이다.</p>

<p>또, 쓰레드가 처한 상황에 따라서, 또는 운영체제가 코어를 쓰레드에 할당하는 방식에 다라서 두 쓰레드의 실행 속도에는 차이가 있을 수 있기 때문에, 여러 쓰레드가 동작할 경우, 그 결과를 쉽게 예상하기란 어렵다.</p>

<p>다음 코드를 보면 알 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreeMultiNoSleepDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// 짝수 출력</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Runnable</span> <span class="n">task2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// 홀수 출력</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task1</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task2</span><span class="o">);</span>

        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 첫 번째 실행</span>
1 0 3 2 5 7 4 6 9 8 11 10 13 12 15 14 17 16 19 18

<span class="c"># 두 번재 실행</span>
0 2 4 6 8 1 3 5 10 12 14 7 9 11 16 18 13 15 17 19

<span class="c"># 세 번째 실행</span>
1 3 5 7 9 11 13 15 17 19 0 2 4 6 8 10 12 14 16 18
</code></pre></div></div>

<p>여기서 보이듯이 각각의 쓰레드는 이렇게 독립적으로 자신의 일을 실행해 나간다.</p>

<h3 id="--쓰레드를-생성하는-두-번째-방법">- <u>쓰레드를 생성하는 두 번째 방법</u></h3>

<p>다음과 같이 Thread 클래스를 상속하여 task를 구성할 수도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Task</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>
		<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="o">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Task</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Task</span><span class="o">();</span>
		<span class="nc">Task</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Task</span><span class="o">();</span>
		
		<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
		<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"End "</span> <span class="o">+</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="34-2-쓰레드의-동기화">34-2. 쓰레드의 동기화</h2>

<h3 id="--쓰레드의-메모리-접근-방식과-그에-따른-문제점">- <u>쓰레드의 메모리 접근 방식과 그에 따른 문제점</u></h3>

<p>쓰레드를 설명할 때 사용하는 단골 예시를 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">synchronized</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">synchronized</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decrement</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MutualAccess</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Counter</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Counter</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Runnable</span> <span class="n">task2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">.</span><span class="na">decrement</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task1</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task2</span><span class="o">);</span>

        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

				<span class="c1">// main 쓰레드가 다른 두 쓰레드의 실행이 완료되기를 기다리기 위해 추가</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cnt</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 실행결과 1</span>
2

<span class="c"># 실행결과 2</span>
0

<span class="c"># 실행결과 3</span>
4
</code></pre></div></div>

<p>결과를 보면 당연히 결과가 0이 될 것이라는 예상과는 다르게 실행할 때마다 다른 결과가 나오는 것을 볼 수 있다.</p>

<p>따라서 자연스럽게 다음을 유추해 볼 수 있다.</p>

<blockquote>
  <p>둘 이상의 쓰레드가 동일한 변수에 접근하는 것은 문제를 일으킬 수 있다.</p>
</blockquote>

<p>그리고 이럴 때 필요한 개념이 바로 동기화(synchronization)이다.</p>

<h3 id="--동일한-메모리-공간에-접근하는-것이-왜-문제가-되는가">- <u>동일한 메모리 공간에 접근하는 것이 왜 문제가 되는가?</u></h3>

<p><img src="/assets/images/java-lang/34-4.png" alt="image" width="50%" height="50%" /><br /></p>

<p>다음과 같이 서로 다른 쓰레드가 같은 자원에 동시에 접근한다고 가정하자.</p>

<p><img src="/assets/images/java-lang/34-5.png" alt="image" width="50%" height="50%" /><br /></p>

<p>값을 바꾸려면</p>

<ol>
  <li>data에서 값을 가져오고</li>
  <li>가져온 값을 증가 시키고</li>
  <li>증가시킨 값을 다시 data에 할당하기</li>
</ol>

<p>위 세 가지 동작 과정을 거쳐야 한다.</p>

<p>하지만, 코어가 여러 개일 때나 코어가 단일 코어더라도 쓰레드가 코어를 나누어 차지하는 시간 조각이 굉장이 작기 때문에 여러 쓰레드가 거의 동시에 값을 가져가는 상황이 생길 수 있다.</p>

<p>이럴 경우에는 위의 그림과 같이 task1이 완전히 끝나기 전에 task 2에서 결과를 가져갈 수도 있는 것이다.</p>

<blockquote>
  <p>따라서, 둘 이상의 쓰레드가 동일한 변수에 동시에 접근하는 상황에서는 한 순간에 한 쓰레드만 변수에 접근하도록 제한할 필요가 있다.</p>
</blockquote>

<h3 id="--동기화synchronization-메소드">- <u>동기화(Synchronization) 메소드</u></h3>

<p>다음과 같이 synchronized 키워드를 통해 메소드 단위로 동기화를 걸 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">synchronized</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">synchronized</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decrement</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 ‘한 클래스의 두 메소드’에 synchronized 선언이 되면, 두 메소드는 둘 이상의 쓰레드에 의해 동시에 실행될 수 없도록 동기화된다.</p>

<h3 id="--동기화synchronization-블록">- <u>동기화(Synchronization) 블록</u></h3>

<p>메소드 전체로 묶을 필요가 없을 때는 다음과 같이 동기화 블록을 사용하는 방법도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decrement</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 this는 Counter 클래스의 인스턴스를 말한다.</p>

<p>즉, Counter 클래스의 인스턴스 내에 위치한 두 동기화 블록은 둘 이상의 쓰레드의 의해 동시에 실행될 수 없도록 함께 동기화된다.</p>

<h2 id="34-3-쓰레드를-생성하는-더-좋은-방법">34-3. 쓰레드를 생성하는 더 좋은 방법</h2>

<h3 id="--지금-소개하는-이-방법으로-쓰레드를-생성하고-활용하자">- <u>지금 소개하는 이 방법으로 쓰레드를 생성하고 활용하자.</u></h3>

<p>쓰레드의 생성과 소멸은 그 자체로 시스템에 부담을 준다.</p>

<p>따라서, 쓰레드 풀(Thread Pool)을 만들고 그 안에서 미리 제한된 수의 쓰레드를 생성해 두고 이를 재활용하는 기술을 사용한다.</p>

<p><img src="/assets/images/java-lang/34-6.png" alt="image" width="60%" height="60%" /><br /></p>

<p>다만, 직접 구현할 필요는 없고, 자바에서 제공하는 concurrent 패키지를 활용하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExecutorsDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>

            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="o">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">));</span>
        <span class="o">};</span>

        <span class="nc">ExecutorService</span> <span class="n">exr</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>   <span class="c1">// Thread Pool에 작업을 전달</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span> <span class="c1">// Thread Pool과 그 안에 있는 Thread의 소멸</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 실행 결과</span>
pool-1-thread-1: 30
</code></pre></div></div>

<p>위의 코드는 싱글쓰레드풀을 생성했지만 Executors 클래스의 여러 메소드들을 통해 다양한 유형의 쓰레드 풀을 생성할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. 풀 안에 하나의 쓰레드만 생성하고 유지한다.</span>
<span class="nc">ExecutorService</span> <span class="n">exr1</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>

<span class="c1">// 2. 풀 안에 인자로 전달된 수의 쓰레드를 생성하고 유지한다.</span>
<span class="nc">ExecutorService</span> <span class="n">exr2</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>

<span class="c1">// 3. 풀 안의 쓰레드의 수를 작업의 수에 맞게 유동적으로 관리한다.</span>
<span class="nc">ExecutorService</span> <span class="n">exr3</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
</code></pre></div></div>

<p>다른 쓰레드 풀을 사용하여 여러 task를 전달해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExecutorDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">7</span><span class="o">));</span>
        <span class="o">};</span>

        <span class="nc">Runnable</span> <span class="n">task2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">7</span><span class="o">));</span>
        <span class="o">};</span>

        <span class="nc">ExecutorService</span> <span class="n">exr</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task1</span><span class="o">);</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task2</span><span class="o">);</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="o">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">7</span><span class="o">));</span>
        <span class="o">});</span>

        <span class="n">exr</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="--callable--future">- <u>Callable &amp; Future</u></h3>

<p>Runnable에 위치한 추상 메소드 run의 반환형은 void이기 때문에 작업의 결과를 받을 수 없다.</p>

<p>이럴 경우, 다음 인터페이스를 기반으로 작업을 구성하면 작업의 끝에서 값을 반환하는 것이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="no">V</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Callable 인터페이스와 Future 인터페이스를 통해 쓰레드가 처리한 작업에 대한 결과를 얻을 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CallableDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">};</span>

        <span class="nc">ExecutorService</span> <span class="n">exr</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>

        <span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">fur</span> <span class="o">=</span> <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fur</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

        <span class="n">exr</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="--synchronized를-대신하는-reentrantlock">- <u>synchronized를 대신하는 ReentrantLock</u></h3>

<p>동기화 블록 대신 ReentrantLock 인스턴스를 이용하는 방법도 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantLock</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">CounterC</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">ReentrantLock</span> <span class="n">criticObj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">criticObj</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">criticObj</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decrement</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">criticObj</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">criticObj</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MutualAccessReentrantLock</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">CounterC</span> <span class="n">cnt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CounterC</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">task1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">Runnable</span> <span class="n">task2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">ExecutorService</span> <span class="n">exr</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task1</span><span class="o">);</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task2</span><span class="o">);</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cnt</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>

        <span class="n">exr</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="--컬렉션-인스턴스-동기화">- <u>컬렉션 인스턴스 동기화</u></h3>

<p>동기화는 그 특성상 어쩔 수 없이 성능의 저하를 수반한다.</p>

<p>이러한 이유로 컬렉션 프레임워크의 클래스 대부분도 동기화 처리가 되어 있지 않다.</p>

<p>따라서, 쓰레드의 동시 접근에 안전하지 않다. 대신 Collections의 다음 메소드들을 통해 동기화 방법을 제공하고 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">synchronizedSet</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">synchronizedList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nf">synchronizedMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Collections</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">synchronizedCollection</span><span class="o">(</span><span class="nc">Collection</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>간단한 예시 코드를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ExecutorService</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.Executors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SyncArrayList</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">lst</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lst</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 컬렉션 인스턴스 자체에 대한 동기화되었다고 해도 이를 기반으로 생성된 반복자까지 동기화가 이뤄지는 것은 아니기 때문</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lst</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">ListIterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">lst</span><span class="o">.</span><span class="na">listIterator</span><span class="o">();</span>

                <span class="k">while</span> <span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">itr</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">next</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="nc">ExecutorService</span> <span class="n">exr</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>

        <span class="n">exr</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
        <span class="n">exr</span><span class="o">.</span><span class="na">awaitTermination</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lst</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="reference">Reference</h2>

<p><a href="https://spacebike.tistory.com/22">[운영체제] Concurrency(동시성)과 Parallelism(병렬성) 이해하기</a></p>]]></content><author><name>hi~ June!!</name></author><category term="Java lang" /><category term="java" /><summary type="html"><![CDATA[Java 문법 정리!]]></summary></entry><entry><title type="html">[1주차 - Frame Work를 위한 Java] String, StringBuffer, StringBuilder</title><link href="http://localhost:4000/java-for-framework/String/" rel="alternate" type="text/html" title="[1주차 - Frame Work를 위한 Java] String, StringBuffer, StringBuilder" /><published>2023-06-07T00:00:00+09:00</published><updated>2023-06-07T00:00:00+09:00</updated><id>http://localhost:4000/java-for-framework/String</id><content type="html" xml:base="http://localhost:4000/java-for-framework/String/"><![CDATA[<h2 id="stringbuilder와-stringbuffer는-무슨-차이가-있는가"><strong>StringBuilder와 StringBuffer는 무슨 차이가 있는가?</strong></h2>
<p>결론부터 말하자면..<br />
<code class="language-plaintext highlighter-rouge">StringBuffer</code>는 멀티 쓰레드 환경에서 안전하지만, 느리다.<br />
<code class="language-plaintext highlighter-rouge">StringBuilder</code>는 멀티 쓰레드 환경에서 안전하지 않지만, 빠르다.</p>

<h2 id="java에서-string을-처리하는-법">Java에서 String을 처리하는 법</h2>
<p>String 클래스의 instance는 immutable이다.<br />
한 번 만들어진 instance는 불변이기 때문에 굳이 내용이 같을 경우 새로운 instance를 생성할 필요가 없다.<br />
따라서 String instance는 java에서 다음과 같이 처리한다.</p>

<p>code를 통해 살펴보자..</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ImmutableString</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="c1">// 문자열 생성 방법 1(literal)</span>
        <span class="nc">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"Simple String"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"Simple String"</span><span class="o">;</span>

        <span class="c1">// 문자열 생성 방법 2(new keyword)</span>
        <span class="nc">String</span> <span class="n">str3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Simple String"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">str4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Simple String"</span><span class="o">);</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span><span class="o">)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1과 str2는 동일 인스턴스 참조"</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str1과 str2는 다른 인스턴스 참조"</span><span class="o">);</span>

        <span class="k">if</span><span class="o">(</span><span class="n">str3</span> <span class="o">==</span> <span class="n">str4</span><span class="o">)</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str3과 str4는 동일 인스턴스 참조"</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"str3과 str4는 다른 인스턴스 참조"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 실행결과</span>
str1과 str2는 동일 인스턴스 참조
str3과 str4는 다른 인스턴스 참조
</code></pre></div></div>

<p>이러한 결과가 나오는 것은 String 인스턴스의 생성 방법에 따라 저장되는 공간이 다르기 때문이다.</p>

<p><img src="/assets/images/DevCourse/java-for-framework/1-1.png" alt="image" width="90%" height="90%" /></p>

<h2 id="stringbuilder-stringbuffer">StringBuilder, StringBuffer</h2>
<p>String의 반복적인 인스턴스 생성은 프로그램의 성능을 저하시킨다.<br />
문자열끼리의 연산은 빈번한 인스턴스의 생성을 야기시킬 수 있으므로 이를 방지하기 위해 <code class="language-plaintext highlighter-rouge">StringBuilder</code>, <code class="language-plaintext highlighter-rouge">StringBuffer</code> 클래스를 사용한다.</p>

<p><code class="language-plaintext highlighter-rouge">StringBuilder</code>, <code class="language-plaintext highlighter-rouge">StringBuffer</code> 클래스는 내부적으로 문자열을 저장하기 위한 메모리 공간을 지닌다.<br />
이 메모리공간은 String 클래스의 메모리 공간과는 다르게 문자를 ‘추가’하거나 ‘삭제’하는 것이 가능하다.<br />
따라서, ‘수정하면서 유지해야 할 문자열’이 있다면 이 클래스에 그 내용을 담아서 관리하는 것이 효율적이다.</p>

<h2 id="똑같은거-아닌가">똑같은거 아닌가?</h2>
<p><code class="language-plaintext highlighter-rouge">StringBuffer</code>와 <code class="language-plaintext highlighter-rouge">StringBuilder</code>는</p>
<ol>
  <li>생성자를 포함한 메소드의 수</li>
  <li>메소드의 기능</li>
  <li>메소드의 이름과 매개변수의 선언<br />
위 세 가지가 일치한다. 이는 사실상 같은 클래스임을 의미한다.</li>
</ol>

<p>기능상으로는 완전히 동일하나 그 내부 동작 과정에서는 차이가 있다.</p>

<blockquote>
  <p>StringBuffer는 쓰레드에 안전하지만, StringBuilder는 쓰레드에 안전하지 않다.</p>
</blockquote>

<p>위의 말은 같은 자원에 대해 여러 thread가 접근할 때, synchronization(동기화) 처리가 되어있는가 와도 같은 말이다.</p>

<ul>
  <li>
    <p>StringBuffer<br />
<img src="/assets/images/DevCourse/java-for-framework/1-2.png" alt="image" width="90%" height="90%" /></p>
  </li>
  <li>
    <p>StringBuilder<br />
<img src="/assets/images/DevCourse/java-for-framework/1-3.png" alt="image" width="90%" height="90%" /></p>
  </li>
</ul>

<h2 id="reference">Reference</h2>
<p><a href="https://velog.io/@heoseungyeon/StringBuilder와-StringBuffer는-무슨-차이가-있는가">StringBuilder와 StringBuffer는 무슨 차이가 있는가?</a></p>]]></content><author><name>hi~ June!!</name></author><category term="java-for-framework" /><category term="java" /><summary type="html"><![CDATA[프로그래머스 데브코스]]></summary></entry><entry><title type="html">[Voice Pocket] Message Queue 뒷 단으로 보낸 작업의 결과를 확인하는 법</title><link href="http://localhost:4000/voice_pocket/Voice_Pocket04/" rel="alternate" type="text/html" title="[Voice Pocket] Message Queue 뒷 단으로 보낸 작업의 결과를 확인하는 법" /><published>2023-05-19T00:00:00+09:00</published><updated>2023-05-19T00:00:00+09:00</updated><id>http://localhost:4000/voice_pocket/Voice_Pocket04</id><content type="html" xml:base="http://localhost:4000/voice_pocket/Voice_Pocket04/"><![CDATA[<h2 id="message-queue-뒷-단에서-수행되는-task에-대해서-서버에서-어떻게-확인할-수-있을까">Message Queue 뒷 단에서 수행되는 task에 대해서 서버에서 어떻게 확인할 수 있을까..?</h2>
<p>음성 합성을 위한 작업은 <code class="language-plaintext highlighter-rouge">python</code> 컨테이너에서 수행되므로 <code class="language-plaintext highlighter-rouge">spring boot</code> 서버에서 컨테이너 쪽으로 작업 메시지를 넘기면 그 작업 결과에 대해 클라이언트가 알 수가 없었다.</p>

<p>하지만 wav 파일 생성을 마치면 해당 wav파일을 <code class="language-plaintext highlighter-rouge">gcs</code> 버킷에 업로드하기 때문에, 클라이언트에서 <code class="language-plaintext highlighter-rouge">gcs</code>로부터 다운로드 받기 위해서는 해당 작업이 끝난 시점을 알아야만 했다.</p>

<p>따라서, 며칠 동안 머리를 싸맨 결과 나름의 해결책을 고안했다.</p>

<h2 id="끝났는지-계속-물어보기polling-방식">끝났는지 계속 물어보기(Polling 방식)</h2>
<p><img src="/assets/images/Voice_Pocket/4-1.png" alt="image" /><br /></p>

<p>당최 해결법이 떠오르지 않다가, 문득 하나의 생각이 머리를 스쳤다.</p>

<blockquote>
  <p>celery backend가 있구나?</p>
</blockquote>

<p>celery는 작업의 결과를 backend에 저장할 수 있다.<br />
이 특성을 이용해서 result backend를 spring boot에서 조회하면서<br />
task id에 해당하는 작업 결과가</p>
<ol>
  <li>result backend에 없으면 작업이 끝나지 않은 것이니 다시 조회 요청</li>
  <li>result backend에 있으면 작업이 끝난 것이니 url을 통해 음성 파일 다운로드 수행</li>
</ol>

<p>이런 방식으로 클라이언트에서 작업의 결과를 받아볼 수 있겠다 싶었고, 실제로 구현까지 완료했다.<br />
다만, 뇌피셜(?)로 나온 구현 방법이라 확신도 서지 않았고, 구현하면서도 바로 문제점이 보였다.</p>

<h2 id="polling-방식에서-나온-여러-문제들">Polling 방식에서 나온 여러 문제들</h2>
<p>여기서, <code class="language-plaintext highlighter-rouge">polling</code> 방식이란,</p>
<blockquote>
  <p>일정한 주기(특정한 시간)을 가지고 서버와 응답을 주고 받는 방식이다.</p>
</blockquote>

<p>음성 합성 작업의 진행상황을 파악하기 위해 작업이 끝날 때까지 일정 간격으로 서버에 request를 요청하는 방식이니 <code class="language-plaintext highlighter-rouge">polling</code> 방식이라고 볼 수 있다.<br />
그리고 이 방법으로는 클라이언트와 서버 둘 다 문제가 있었다.</p>

<ul>
  <li>클라이언트(Flutter)
    <ul>
      <li>TTS 작업을 요청한 뒤, 완료 response를 얻어낼 때까지, foreground로 request를 지속해서 보내야하기 때문에 다른 작업을 못했다.</li>
    </ul>
  </li>
  <li>서버(Spring Boot)
    <ul>
      <li>폴링의 주기가 짧으면 서버의 성능에 부담이 간다. (오버헤드/트래픽)</li>
      <li>주기가 길면 실시간성이 떨어진다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>음성 합성에는 대략 8~9초 정도가 소요되는데, 그 시간동안 앱에서 로딩바를 보고있어라..?</p>
</blockquote>

<p>생각만으로도 부정적 경험이다.<br />
안타깝게도, 별다른 방법이 떠오르지 않아, 저번처럼 멘토님께 SOS를 요청했다.</p>

<h2 id="backend-server를-producer면서-consumer로도-활용할-수-있지요">backend server를 producer면서 consumer로도 활용할 수 있지요</h2>
<p><img src="/assets/images/Voice_Pocket/4-2.png" alt="image" /><br /></p>

<p>말 그대로다..<br />
너무 단방향으로만 사고를 했던 것 같다.<br />
작업이 끝났으면 끝났다는 message를 역방향으로 Queue에 실어주면 그만이었다.<br />
<code class="language-plaintext highlighter-rouge">spring boot</code>와 <code class="language-plaintext highlighter-rouge">celery worker</code>를 각각 producer와 consumer 역할을 모두 수행하도록 구성할 수도 있다는 생각은 못 했던 것 같다.</p>

<p>작업이 완료되면 작업이 완료되었다는 알림을 <code class="language-plaintext highlighter-rouge">FCM</code>(Firebase Cloud Messaging)을 통해 client application에 알려주기로 했다.</p>

<h2 id="번외-notify는-어디서-해줘야되지">번외) notify는 어디서 해줘야되지..?</h2>
<p>사실 처음에는 <code class="language-plaintext highlighter-rouge">celery worker</code>가 wav 파일 생성을 마치고 <code class="language-plaintext highlighter-rouge">FCM</code>에 push request를 보내는 일까지 시키려고 했다.<br />
하지만, ‘각 작업에 대한 책임은 분리하는게 좋다’고 조언해주셔서 <code class="language-plaintext highlighter-rouge">FCM</code>에 관한 작업은 <code class="language-plaintext highlighter-rouge">spring boot</code> 서버에서 수행하도록 구성했다.</p>

<blockquote>
  <p>이로써 python 컨테이너는 오로지 음성 합성에 대한 작업만,<br />
spring boot 서버는 클라이언트와 소통하는 작업만 수행할 수 있도록 구현되었다.</p>
</blockquote>

<p>클래스, 메소드는 기능단위로 딱딱 분리해가며 구현해왔으면서 순간 별 생각없이 구현할 뻔 했다..ㅎㅎ</p>]]></content><author><name>hi~ June!!</name></author><category term="Voice_Pocket" /><category term="Info" /><summary type="html"><![CDATA[Voice Pocket의 프로젝트]]></summary></entry><entry><title type="html">[혼자왔니] postGIS를 활용한 인근 피드 조회</title><link href="http://localhost:4000/rualone/RUAlone04/" rel="alternate" type="text/html" title="[혼자왔니] postGIS를 활용한 인근 피드 조회" /><published>2023-05-11T00:00:00+09:00</published><updated>2023-05-11T00:00:00+09:00</updated><id>http://localhost:4000/rualone/RUAlone04</id><content type="html" xml:base="http://localhost:4000/rualone/RUAlone04/"><![CDATA[<h2 id="공간-데이터를-다뤄야-하는-상황">공간 데이터를 다뤄야 하는 상황</h2>
<p>사용자의 모집글에는 다음과 같은 내용이 포함된다.<br />
<img src="/assets/images/RUAlone/4-1.png" alt="image" width="80%" height="80%" /></p>

<p>따라서, 사용자가 게시글을 검색할 때 자신의 현재 위치 근방 1.5km 내에 있는 음식점들에 대한 모집글만 조회할 수 있도록 기능을 만들기 위해 자신의 위치 인근 게시글을 탐색해야 하는 상황이 생긴다.</p>

<h2 id="postgresql의-postgis-익스텐션을-활용해보자">postgreSQL의 postGIS 익스텐션을 활용해보자.</h2>
<p>공간 데이터를 다룰 때 사용성과 성능 측면에서 월등하다고 알려진 <code class="language-plaintext highlighter-rouge">postgreSQL</code>의 <code class="language-plaintext highlighter-rouge">postGIS</code>를 사용해보기로 했다.</p>

<h2 id="라이브러리-및-설정-파일-세팅">라이브러리 및 설정 파일 세팅</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// hibernate-spatial</span>
<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">hibernate</span><span class="o">:</span><span class="n">hibernate</span><span class="o">-</span><span class="nl">spatial:</span><span class="mf">5.6</span><span class="o">.</span><span class="mi">11</span><span class="o">.</span><span class="na">Final</span><span class="err">'</span>

<span class="c1">// postgresql</span>
<span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">postgresql</span><span class="o">:</span><span class="nl">postgresql:</span><span class="mf">42.5</span><span class="o">.</span><span class="mi">4</span><span class="err">'</span>
</code></pre></div></div>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">datasource</span><span class="pi">:</span>
    <span class="na">driver-class-name</span><span class="pi">:</span> <span class="s">org.postgresql.Driver</span>
    <span class="na">url</span><span class="pi">:</span> <span class="c1"># url</span>
    <span class="na">username</span><span class="pi">:</span> <span class="c1"># username</span>
    <span class="na">password</span><span class="pi">:</span> <span class="c1"># password</span>

  <span class="na">jpa</span><span class="pi">:</span>
    <span class="na">database</span><span class="pi">:</span> <span class="s">postgresql</span>
    <span class="na">database-platform</span><span class="pi">:</span> <span class="s">org.hibernate.spatial.dialect.postgis.PostgisPG95Dialect</span>
</code></pre></div></div>

<h2 id="point-객체를-이용해서-위치에-대한-정보를-저장하자">Point 객체를 이용해서 위치에 대한 정보를 저장하자.</h2>
<p>사용자의 좌표, 음식점의 좌표 이 두 가지 값을 가지고 둘 사이의 거리를 측정하여 일정 거리 미만에 해당하는 값들만 불러올 예정이다. 따라서 위도, 경도로 초기화시킨 <code class="language-plaintext highlighter-rouge">point</code> 객체가 필요하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"post"</span><span class="o">)</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">columnDefinition</span> <span class="o">=</span> <span class="s">"geometry(Point, 4326)"</span><span class="o">,</span> <span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Point</span> <span class="n">restaurantPoint</span><span class="o">;</span>  <span class="c1">// 음식점(Point) 객체</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.locationtech.jts.geom.*</span><span class="o">;</span>

<span class="c1">// 0(좌표 평면), 4326(위도-경도 좌표계)</span>
<span class="kd">private</span> <span class="nc">GeometryFactory</span> <span class="n">geometryFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GeometryFactory</span><span class="o">(</span><span class="k">new</span> <span class="nc">PrecisionModel</span><span class="o">(),</span> <span class="mi">4326</span><span class="o">);</span>  

<span class="cm">/**
 * 위도, 경도를 받아 Point 객체를 반환하는 메소드
 *
 * @param latitude
 * @param longitude
 * @return
 */</span>
<span class="kd">private</span> <span class="nc">Point</span> <span class="nf">getPoint</span><span class="o">(</span><span class="kt">double</span> <span class="n">latitude</span><span class="o">,</span> <span class="kt">double</span> <span class="n">longitude</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="n">geometryFactory</span><span class="o">.</span><span class="na">createPoint</span><span class="o">(</span><span class="k">new</span> <span class="nc">Coordinate</span><span class="o">(</span><span class="n">latitude</span><span class="o">,</span> <span class="n">longitude</span><span class="o">));</span>

    <span class="k">return</span> <span class="n">point</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SRID</code>는 좌표계를 나타내는 값으로, 자주 사용하는 값은 0(좌표평면)과 4326(위도-경도 좌표계)이다.<br />
<code class="language-plaintext highlighter-rouge">PostGI</code>S와 <code class="language-plaintext highlighter-rouge">MySQL</code>의 가장 큰 차이점은 바로 4326 좌표계에서도 다양한 함수를 사용할 수 있다는 것이다.<br />
(<code class="language-plaintext highlighter-rouge">MySQL</code>은 4326으로 지정해도 결국 좌표평면 좌표계 기준으로 공간 데이터를 다룬다)</p>

<h2 id="인근-게시글을-조회하기-위한-쿼리를-작성해보자">인근 게시글을 조회하기 위한 쿼리를 작성해보자.</h2>
<p><code class="language-plaintext highlighter-rouge">postGIS</code>에는 거리를 측정하는 다양한 함수가 있다.<br />
그 중 <code class="language-plaintext highlighter-rouge">ST_DWithin</code> 함수를 사용하고자 한다.<br />
해당 함수를 <code class="language-plaintext highlighter-rouge">JPQL</code> 형식으로 PostRepository에 적용시켜주었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PostRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Query</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"select p from Post p where dwithin(p.restaurantPoint, :point, 1500, false) is true and p.isActive is true"</span><span class="o">)</span>
    <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Post</span><span class="o">&gt;</span> <span class="nf">findPostByDistance</span><span class="o">(</span><span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">,</span> <span class="nc">Point</span> <span class="n">point</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="더-살펴볼-내용들">더 살펴볼 내용들</h2>
<p><img src="/assets/images/RUAlone/4-2.png" alt="image" width="40%" height="40%" /></p>

<p>아무래도 인근 좌표를 찾기 위해 왠지 post table을 full scan할 것 같다는 것이 조금 우려스럽다.<br />
따라서,</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">point</code> 객체가 적용되어있는 restaurant_point column에 인덱스를 건다든지,</li>
  <li><code class="language-plaintext highlighter-rouge">ST_DWithin</code> 함수 외에 <code class="language-plaintext highlighter-rouge">postGIS</code>에서 제공하는 거리 측정 관련 여러 함수들의 <code class="language-plaintext highlighter-rouge">query plan</code>을 비교하여 더 적합한 함수를 찾는 등</li>
</ol>

<p>추후에 성능적인 이슈를 생각해보려고 한다.</p>

<h2 id="reference">Reference</h2>
<p>1) <a href="https://gksdudrb922.tistory.com/245">https://gksdudrb922.tistory.com/245</a> [postGIS 초기 세팅]</p>]]></content><author><name>hi~ June!!</name></author><category term="RUAlone" /><category term="Info" /><summary type="html"><![CDATA[RUAlone(혼자왔니) 혼밥 메이트 구하기 프로젝트]]></summary></entry><entry><title type="html">[혼자왔니] 채팅 서버 구현을 통해 알아본 redis와 kafka의 차이점</title><link href="http://localhost:4000/rualone/RUAlone05/" rel="alternate" type="text/html" title="[혼자왔니] 채팅 서버 구현을 통해 알아본 redis와 kafka의 차이점" /><published>2023-05-11T00:00:00+09:00</published><updated>2023-05-14T00:00:00+09:00</updated><id>http://localhost:4000/rualone/RUAlone05</id><content type="html" xml:base="http://localhost:4000/rualone/RUAlone05/"><![CDATA[<h2 id="채팅기능이-필요하다">채팅기능이 필요하다..</h2>
<p>예를 들어 같이 배달을 시킬 사람을 모집하는 글을 올렸다면,<br />
언제 모일건지, 어떤 메뉴를 시킬 건지, 결제는 어떻게 할 것인지 등등<br />
모인 사람들끼리 대화를 할 수 있는 공간이 필요했다.<br />
해당 기능 추가를 위해 채팅용 서버를 토이 프로젝트로 진행해보았다.</p>

<h2 id="pubsub-구조란">pub/sub 구조란?</h2>
<blockquote>
  <p>메시지를 공급하는 주체와 소비하는 주체를 분리하여 제공하는 메시징 방법</p>
</blockquote>

<p><img src="/assets/images/RUAlone/5-1.png" alt="image" width="85%" height="85%" class="align-center" /></p>

<ul>
  <li>채팅방(우체통)을 생성한다: <code class="language-plaintext highlighter-rouge">pub/sub</code> 구현을 위한 <code class="language-plaintext highlighter-rouge">Topic</code>이 하나 생성된다.</li>
  <li>채팅방(우체통)에 입장한다: <code class="language-plaintext highlighter-rouge">Topic</code>을 구독한다.</li>
  <li>채팅방에서 메시지를 보내고 받는다: 해당 <code class="language-plaintext highlighter-rouge">Topic</code>으로 메시지를 발송하거나(<code class="language-plaintext highlighter-rouge">pub</code>-집배원) 메시지를 받는다(<code class="language-plaintext highlighter-rouge">sub</code>-구독자)</li>
</ul>

<h2 id="web-socket과-stomp">Web Socket과 STOMP</h2>
<p><img src="/assets/images/RUAlone/5-2.png" alt="image" width="80%" height="80%" class="align-center" /></p>

<ul>
  <li>Web Socket
    <ul>
      <li>Websocket만을 이용해 채팅을 구현하면 해당 메시지가 어떤 요청인지, 어떻게 처리해야 되는지에 따라 채팅룸과 세션을 일일이 구현하고 메시지 발송 부분을 관리하는 추가 코드를 구현해 줘야한다.</li>
    </ul>
  </li>
  <li>STOMP
    <ul>
      <li>메시징 전송을 효율적으로 하기 위해 나온 프로토콜</li>
      <li>pub/sub 구조로 되어있어 메시지를 발송하고, 메시지를 받아 처리하는 부분이 명확이 구분되어 있어 개발 시 명확히 인지하고 개발하기 쉽다는 이점이 있음</li>
      <li>통신 메시지의 헤더에 값을 세팅할 수 있어 헤더 값을 기반으로 통신 시 인증처리를 구현하는 것도 가능함</li>
    </ul>
  </li>
</ul>

<h2 id="채팅-서비스의-고도화">채팅 서비스의 고도화</h2>
<blockquote>
  <p>web socket과 STOMP 만을 이용해서 만든 채팅 서버를 고도화시켜보자..!</p>
</blockquote>

<ul>
  <li>서버를 재시작 할때마다 채팅방 정보들이 리셋된다.
    <ul>
      <li>채팅방의 저장소가 없으므로 서버의 메모리에 적재된 채팅방은 서버를 재시작할 때마다 초기화되는 이슈가 있다.
        <ul>
          <li>DB 혹은 다른 저장소를 이용하여 채팅방이 계속 유지되도록 처리가 필요함(<code class="language-plaintext highlighter-rouge">redis</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>채팅서버가 여러대일 때 서버간 채팅방 공유가 불가능함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">websocket</code>과 <code class="language-plaintext highlighter-rouge">STOMP</code> <code class="language-plaintext highlighter-rouge">pub/sub</code> 을 이용하여 구현할 시, <code class="language-plaintext highlighter-rouge">pub/sub</code>이 발생한 서버 내에서만 메시지를 주고받는 것이 가능함
        <ul>
          <li>채팅방(<code class="language-plaintext highlighter-rouge">topic</code>)이 생성된 서버 안에서만 유효하므로 다른 서버로 접속한 클라이언트는 접근 및 구독이 불가능하다.</li>
        </ul>
      </li>
      <li>즉, 구독 대상(채팅방: <code class="language-plaintext highlighter-rouge">topic</code>)이 여러 서버에서 접근할 수 있도록 개선이 필요하다. (<code class="language-plaintext highlighter-rouge">redis</code>, <code class="language-plaintext highlighter-rouge">kafka</code>, <code class="language-plaintext highlighter-rouge">rabbitMQ</code> 등등)</li>
    </ul>
  </li>
</ul>

<h2 id="두-가지-방법으로-구현해본-채팅-서버">두 가지 방법으로 구현해본 채팅 서버</h2>
<p>spring boot와 web socket 및 message queue를 이용하여 채팅 서버를 만들어봤다.<br />
구체적인 구현 방법은 잘 정리해놓은 블로그를 reference에 남겨놓는 것으로 하고,<br />
<code class="language-plaintext highlighter-rouge">redis</code>, <code class="language-plaintext highlighter-rouge">kafka</code> 이렇게 총 2가지 message queue를 이용해서 구현해보면서 느꼈던 차이점에 대해서 정리해보려고 한다.</p>

<p>전반적인 동작 과정은 다음과 같다.</p>
<ol>
  <li>채팅방을 생성하면, <code class="language-plaintext highlighter-rouge">redis</code> 저장소에 채팅방 정보를 저장</li>
  <li>채팅방에 입장하면 <code class="language-plaintext highlighter-rouge">web socket</code> 연결이 수행되고, 해당 채팅방에 대한 <code class="language-plaintext highlighter-rouge">subscribe</code>(구독)을 수행한다.</li>
  <li>해당 채팅방에 message request를 보내면, message를 받아서 <code class="language-plaintext highlighter-rouge">message queue</code>(<code class="language-plaintext highlighter-rouge">redis</code> or <code class="language-plaintext highlighter-rouge">kafka</code>)에 <code class="language-plaintext highlighter-rouge">publish</code> 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">message queue</code>(<code class="language-plaintext highlighter-rouge">redis</code> or <code class="language-plaintext highlighter-rouge">kafka</code>)에 대한 <code class="language-plaintext highlighter-rouge">subscriber</code>가 <code class="language-plaintext highlighter-rouge">web socket</code> 구독자에게 해당 채팅 메시지를 보낸다.</li>
</ol>

<h2 id="redis를-사용하여-구현">Redis를 사용하여 구현</h2>
<p><img src="/assets/images/RUAlone/5-3.png" alt="image" width="90%" height="90%" class="align-center" /></p>

<p><code class="language-plaintext highlighter-rouge">redis</code>를 사용할 경우,<br />
message가 <code class="language-plaintext highlighter-rouge">publish</code> 되면 해당 <code class="language-plaintext highlighter-rouge">channel</code>을 구독하고 있는 모든 <code class="language-plaintext highlighter-rouge">subscriber</code>에게 message를 보내주게된다.<br />
따라서, 각기 다른 채팅 서버를 통해 접속했더라도 같은 채팅방에서 서로 대화할 수 있는 것이다.</p>

<p>다만, <code class="language-plaintext highlighter-rouge">redis</code>는 보낸 message를 따로 저장하지는 않기 때문에, 해당 <code class="language-plaintext highlighter-rouge">channel</code>을 <code class="language-plaintext highlighter-rouge">subscribe</code>하고 있지 않다면, message가 유실될 수 있다는 단점이 있다.</p>

<p>[8080 서버: 짱구 &amp; 철수, 8090 서버: 맹구]<br />
<img src="/assets/images/RUAlone/redis.gif" alt="image" width="100%" height="100%" class="align-center" /></p>

<h2 id="kafka를-사용하여-구현">Kafka를 사용하여 구현</h2>
<p><img src="/assets/images/RUAlone/5-4.png" alt="image" width="90%" height="90%" class="align-center" /></p>

<p><code class="language-plaintext highlighter-rouge">kafka</code>를 사용할 경우,<br />
message가 <code class="language-plaintext highlighter-rouge">publish</code> 되면 해당 message는 <code class="language-plaintext highlighter-rouge">topic</code>의 각 <code class="language-plaintext highlighter-rouge">partition</code>에 분산되어 저장된다.<br />
따라서, <code class="language-plaintext highlighter-rouge">redis</code>와는 다르게 message의 유실에서는 더 안전하다고 볼 수 있다.</p>

<p>또, <code class="language-plaintext highlighter-rouge">kafka</code>의 경우 <code class="language-plaintext highlighter-rouge">consumer</code>가 message를 가져오는 방식으로 동작한다.<br />
각 message에 <code class="language-plaintext highlighter-rouge">offset</code>을 할당해서 할당된 <code class="language-plaintext highlighter-rouge">offset</code>을 기반으로 <code class="language-plaintext highlighter-rouge">consumer</code>는 다음으로 가져올 메시지의 위치를 지정하여 메시지를 가져오게 된다.<br />
이러한 특징 때문에 메시지의 순서를 보장할 수 있다.</p>

<p>자, 여기까지만 알고, 기존에 짰던 <code class="language-plaintext highlighter-rouge">redis</code> 기반의 채팅 서버를 <code class="language-plaintext highlighter-rouge">kafka</code>로 바꾸니까 원하는대로 동작하지 않았다.</p>

<h2 id="뭐가-문제일까">뭐가 문제일까..</h2>
<p>각각 8080과 8090포트로 서버를 띄워 접속해봤고, 채팅 메시지가 제대로 전달되지 않는 것을 확인할 수 있었다.</p>

<p>[8080 서버: 짱구 &amp; 철수, 8090 서버: 맹구]<br />
<img src="/assets/images/RUAlone/kafka1.gif" alt="image" width="100%" height="100%" class="align-center" /></p>

<p>그리고 medium에서 왜 그런 것인지 확인할 수 있었다.</p>

<h2 id="redis와-kafka의-동작-방식-차이">redis와 kafka의 동작 방식 차이</h2>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">redis</code>는 <code class="language-plaintext highlighter-rouge">kafka</code>와는 달리, <code class="language-plaintext highlighter-rouge">channel</code>에 도착한 message를 해당 <code class="language-plaintext highlighter-rouge">channel</code>을 구독하고 있는 ‘모든’ <code class="language-plaintext highlighter-rouge">subscriber</code>들에게 쏴 줄 수 있다.<br />
따라서, 각각 다른 서버여도 같은 <code class="language-plaintext highlighter-rouge">channel</code>을 구독하고 있기만 하면 message를 받아볼 수 있는 것이다.</p>
</blockquote>

<p>medium에서는 이를 TV 채널을 시청하는 것에 비유하였다.<br />
해당 방송사(<code class="language-plaintext highlighter-rouge">producer</code>)에서 방영하는 라이브 방송은 해당 채널을 시청 중일 때, 같은 시간대에 같은 채널의 시청자들은 모두 같은 방송을 볼 수 있는 것에 비유했다.</p>

<blockquote>
  <p>하지만 <code class="language-plaintext highlighter-rouge">kafka</code>는 다르다.<br />
<code class="language-plaintext highlighter-rouge">topic</code>에 message가 도착하면, 이를 소비하는 것은 <code class="language-plaintext highlighter-rouge">consumer group</code> 단위로 이루어진다.<br />
즉, <code class="language-plaintext highlighter-rouge">consumer</code> 들이 같은 <code class="language-plaintext highlighter-rouge">group</code>에 속해 있다면, message는 해당 <code class="language-plaintext highlighter-rouge">group</code>에 있는 어느 <code class="language-plaintext highlighter-rouge">consumer</code> 중 하나에 의해서 소비된다는 것이다.</p>
</blockquote>

<p>medium에서는 이를 우체통에 비유하였다.<br />
철수(<code class="language-plaintext highlighter-rouge">producer</code>)가 편지를 써서 우체통(<code class="language-plaintext highlighter-rouge">topic</code>)에 넣어두었다면, 해당 편지는 누군가에 의해 발견될 때까지는 남아있을 것이고,<br />
가족(<code class="language-plaintext highlighter-rouge">consumer group</code>) 중 어느 누군가에 의해 발견될 수 있을 것이다.<br />
만약 영희네 오빠가 먼저 발견했다면, 영희는 편지의 존재조차 모르게 되는 것이다.</p>

<h2 id="그럼-어떻게-해야할까">그럼 어떻게 해야할까..?</h2>
<p>애초에 message queue를 둔 이유도, scale-out 등의 이유로 서버가 여럿이 있을 때 해결하려고 도입했던 것인데, <code class="language-plaintext highlighter-rouge">kafka</code>에서는 어떻게 해결할 수 있을까?</p>

<p><img src="/assets/images/RUAlone/5-6.png" alt="image" width="90%" height="90%" class="align-center" /><br />
이 말에서 힌트를 얻었다.</p>

<p><img src="/assets/images/RUAlone/5-5.png" alt="image" width="90%" height="90%" class="align-center" /><br />
위의 그림처럼 서버 별로 group id를 다르게 해주었다.<br />
아쉽게도 동적으로 할당한 것은 아니지만, group id를 서버별로 다르게 하고, 빌드하여 테스트를 진행해보았다.</p>

<p>[8080 서버: 짱구 &amp; 철수, 8090 서버: 맹구]<br />
<img src="/assets/images/RUAlone/kafka2.gif" alt="image" width="100%" height="100%" class="align-center" /></p>

<p><br /></p>

<p>(코드 보러가기)<br />
<a href="https://github.com/hi-june/chat-demo">https://github.com/hi-june/chat-demo</a></p>

<h2 id="reference">Reference</h2>
<p>1) <a href="https://www.daddyprogrammer.org/post/4077/spring-websocket-chatting/">https://www.daddyprogrammer.org/post/4077/spring-websocket-chatting/</a> [websocket으로 채팅 서버 만들기]
2) <a href="https://medium.com/frientrip/pub-sub-%EC%9E%98-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-de9dc1b9f739">https://medium.com/frientrip/pub-sub-%EC%9E%98-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-de9dc1b9f739</a> [pub/sub 잘 알고 쓰자!]</p>]]></content><author><name>hi~ June!!</name></author><category term="RUAlone" /><category term="Info" /><summary type="html"><![CDATA[RUAlone(혼자왔니) 혼밥 메이트 구하기 프로젝트]]></summary></entry><entry><title type="html">[Voice Pocket] TTS 작업 속도 개선기</title><link href="http://localhost:4000/voice_pocket/Voice_Pocket03/" rel="alternate" type="text/html" title="[Voice Pocket] TTS 작업 속도 개선기" /><published>2023-05-03T00:00:00+09:00</published><updated>2023-05-03T00:00:00+09:00</updated><id>http://localhost:4000/voice_pocket/Voice_Pocket03</id><content type="html" xml:base="http://localhost:4000/voice_pocket/Voice_Pocket03/"><![CDATA[<h2 id="음성-합성을-위한-과정">음성 합성을 위한 과정</h2>
<p>사용자의 요청에 따라 음성 파일을 합성하는 전반적인 과정은 다음과 같다.</p>

<p>1) 클라이언트 요청<br />
2) 해당 음성 모델로부터 Systhesizer object initialize</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">synthesizer</span> <span class="o">=</span> <span class="n">Synthesizer</span><span class="p">(</span>
            <span class="n">tts_checkpoint</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">tts_model_file_path</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
            <span class="n">tts_config_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">tts_config_path</span><span class="si">}</span><span class="s">"</span>
        <span class="p">)</span>
</code></pre></div></div>

<p>3) 2에서 만든 Synthesizer object로부터 tts 함수 호출(wav 파일 생성)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">symbol</span> <span class="o">=</span> <span class="n">synthesizer</span><span class="p">.</span><span class="n">tts_config</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">characters</span>   <span class="c1"># symbol set
</span><span class="n">text</span> <span class="o">=</span> <span class="n">normalize_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span> <span class="c1"># text normalize
</span><span class="n">wav</span> <span class="o">=</span> <span class="n">synthesizer</span><span class="p">.</span><span class="n">tts</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="c1"># conver text to speech
</span><span class="n">synthesizer</span><span class="p">.</span><span class="n">save_wav</span><span class="p">(</span><span class="n">wav</span><span class="p">,</span> <span class="n">wav_path</span><span class="p">)</span> <span class="c1"># write wav file
</span></code></pre></div></div>

<p>4) 생성된 wav 파일을 gcs(google cloud storage) bucket에 저장</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">upload_wav_to_bucket</span><span class="p">(</span><span class="n">wav_path</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">uuid</span><span class="p">):</span>
    <span class="n">storage_client</span> <span class="o">=</span> <span class="n">storage</span><span class="p">.</span><span class="n">Client</span><span class="p">()</span>
    
    <span class="n">bucket_name</span> <span class="o">=</span> <span class="n">BUCKET_NAME</span>
    <span class="n">source_file_name</span> <span class="o">=</span> <span class="n">wav_path</span>
    <span class="n">destination_blob_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">email</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">uuid</span><span class="si">}</span><span class="s">.wav'</span>
    
    <span class="n">bucket</span> <span class="o">=</span> <span class="n">storage_client</span><span class="p">.</span><span class="n">bucket</span><span class="p">(</span><span class="n">bucket_name</span><span class="p">)</span>
    <span class="n">blob</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="n">blob</span><span class="p">(</span><span class="n">destination_blob_name</span><span class="p">)</span>

    <span class="n">blob</span><span class="p">.</span><span class="n">upload_from_filename</span><span class="p">(</span><span class="n">source_file_name</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="문제는-너무-느리다는-것">문제는 너무 느리다는 것..</h2>
<p>음성 하나 합성하는데 걸리는 시간이 너무 느리다는 것이 계속 걸렸다.</p>

<p>2번과 3번 과정이 가장 핵심적인 부분이었고, 각각 과정(특히, 2번)들에서 많은 시간이 소요되었다.</p>

<p>애초에 <code class="language-plaintext highlighter-rouge">coqui-tts</code>에서 제공하는 라이브러리를 사용하여 음성 합성을 진행하고 있기 때문에,<br />
위의 과정 중 3번에 해당하는 text를 기반으로 wav 파일을 합성하는 데 걸리는 시간은 건드리기 힘들었다.</p>

<blockquote>
  <p>따라서, 작업 요청마다 Synthesizer instance가 initialize되는 시간만 날려버려도, 시간을 상당히 많이 줄일 수 있을 것이라 판단했고, 해당 부분에 cache를 적용하기로 했다.</p>
</blockquote>

<h2 id="redis-cache">redis cache</h2>
<p><code class="language-plaintext highlighter-rouge">redis</code>는 간단히 설명하자면 key-value 형식으로 데이터를 저장하는 in-memory 기반의 데이터베이스이다.</p>

<p>애초에 gpu 서버에서 음성 학습을 시키고, 모델이 만들어질 때,<br />
해당 모델 파일로부터 synthesizer를 initialize하여 synthesizer object를 redis 캐시에 저장해두고,<br />
필요한 순간에 가져다가 쓸 수 있다면, 요청마다 initiaize되는 시간을 줄일 수 있을 것이라고 생각했다.</p>

<p>정리하자면,</p>
<ul>
  <li>
    <p>음성 모델 학습이 끝나고<br />
1) 음성 모델 합성이 완료되면 해당 모델을 기반으로 synthesizer object를 initialize.<br />
2) synthesizer object를 redis에 저장</p>
  </li>
  <li>
    <p>음성 합성 요청 시<br />
1) 클라이언트 요청<br />
2) redis에 접근하여 미리 저장해둔 synthesizer objcet를 불러옴<br />
3) 불러온 object로 TTS 수행</p>
  </li>
</ul>

<h2 id="class의-instance를-redis에-저장할-수-있을까">class의 instance를 redis에 저장할 수 있을까?</h2>
<p><code class="language-plaintext highlighter-rouge">redis</code>에서는 value로 다양한 data type을 지원한다.<br />
대표적으로 string을 지원하므로 python의 pickle 모듈을 사용하여 객체를 문자열로 직렬화하여 저장하는 방식을 사용했다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">redis</span>

<span class="c1"># 레디스 연결
</span><span class="n">rd</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'{host_name}'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">port_num</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="n">db_num</span><span class="p">)</span>

<span class="c1"># synthesizer initialize
</span><span class="n">synthesizer</span> <span class="o">=</span> <span class="n">Synthesizer</span><span class="p">(</span>
            <span class="n">tts_checkpoint</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">tts_model_file_path</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
            <span class="n">tts_config_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">tts_config_path</span><span class="si">}</span><span class="s">"</span>
        <span class="p">)</span>

<span class="c1"># synthesizer 객체를 pickle로 serialize하여 redis에 저장
</span><span class="n">serialized_syn</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">synthesizer</span><span class="p">)</span>
<span class="n">rd</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">serialized_syn</span><span class="p">)</span>
    
<span class="c1"># redis에 저장해둔 객체를 불러옴
</span><span class="n">serialized_syn</span> <span class="o">=</span> <span class="n">rd</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
<span class="n">syn</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">serialized_syn</span><span class="p">)</span>

<span class="n">symbol</span> <span class="o">=</span> <span class="n">syn</span><span class="p">.</span><span class="n">tts_config</span><span class="p">.</span><span class="n">characters</span><span class="p">.</span><span class="n">characters</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">normalize_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
<span class="n">wav</span> <span class="o">=</span> <span class="n">syn</span><span class="p">.</span><span class="n">tts</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="n">syn</span><span class="p">.</span><span class="n">save_wav</span><span class="p">(</span><span class="n">wav</span><span class="p">,</span> <span class="n">WAV_PATH</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="수행-결과">수행 결과</h2>
<p>같은 길이의 문장을 기준으로 캐시를 적용하기 전과 후를 비교해보았다.</p>

<ul>
  <li>
    <p>적용 전<br />
<img src="/assets/images/Voice_Pocket/3-1.png" alt="image" /><br /></p>
  </li>
  <li>
    <p>적용 후<br />
<img src="/assets/images/Voice_Pocket/3-2.png" alt="image" /><br /></p>
  </li>
</ul>

<p>cache를 적용하여 해당 작업을 21초에서 8초로 줄일 수 있었다!</p>]]></content><author><name>hi~ June!!</name></author><category term="Voice_Pocket" /><category term="Info" /><summary type="html"><![CDATA[Voice Pocket의 프로젝트]]></summary></entry><entry><title type="html">[Voice Pocket] spring boot에서 celery 활용하기</title><link href="http://localhost:4000/voice_pocket/Voice_Pocket02/" rel="alternate" type="text/html" title="[Voice Pocket] spring boot에서 celery 활용하기" /><published>2023-05-03T00:00:00+09:00</published><updated>2023-05-03T00:00:00+09:00</updated><id>http://localhost:4000/voice_pocket/Voice_Pocket02</id><content type="html" xml:base="http://localhost:4000/voice_pocket/Voice_Pocket02/"><![CDATA[<h2 id="굳이-django를-써야할까">굳이 django를 써야할까..?</h2>
<p>한이음 멘토님과 프로젝트 관련 이야기를 하다가, 이런 이야기가 나왔다.</p>

<p><u>나</u>: 음성 합성 관련 라이브러리가 python으로 쓰여서 백엔드 서버도 <code class="language-plaintext highlighter-rouge">django</code>를 사용하고 있습니다 ㅠㅠ<br />
<u>멘토님</u>: 음.. 서버가 요청을 <code class="language-plaintext highlighter-rouge">rabbitMQ</code> 같은 message queue에 publish하면, python으로 받아서 처리하면 되니 굳이 서버까지 python으로 만들 필요는 없지요<br />
<u>나</u>: (생각해보니 그렇네…!)</p>

<h2 id="서버-개발-언어에-굳이-제약을-걸-필요가-없겠구나">서버 개발 언어에 굳이 제약을 걸 필요가 없겠구나!</h2>
<p>아무래도 이제는 <code class="language-plaintext highlighter-rouge">django</code>보단 <code class="language-plaintext highlighter-rouge">spring boot</code>가 더 익숙하기도 하고, 요즘 적극적으로 공부하고 있는 프레임워크이기 때문에 굳이 python을 사용해야하는 상황이 아니라면 <code class="language-plaintext highlighter-rouge">django</code>를 고집하고 있을 이유도 없겠다는 생각에 기존에 구현해뒀던 서버를 <code class="language-plaintext highlighter-rouge">spring boot</code>로 변경하게 되었다.</p>

<blockquote>
  <p>spring boot(java, TTS 요청) → RabbitMQ → Celery(python, TTS 수행)</p>
</blockquote>

<p><img src="/assets/images/Voice_Pocket/2-3.png" alt="image" /><br /></p>

<h2 id="python-celery를-사용하기">python celery를 사용하기</h2>
<p>python에서는 기본적으로 동기식으로 일을 처리한다.<br />
<img src="/assets/images/Voice_Pocket/2-2.png" alt="image" /><br /></p>

<p>즉, 5명의 사용자가 TTS를 요청한다면, 5번 째 요청한 사람은 앞에 4명의 작업이 끝날 때까지 기다리고 있어야한다.<br />
해당 작업은 시간이 꽤 걸리는 작업이기 때문에 작업을 비동기적으로 처리해줄 방법이 필요했고, 그래서 찾은 것이 <code class="language-plaintext highlighter-rouge">celery</code>이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">Celery</span>

<span class="c1"># celery app 정의
</span><span class="n">app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">()</span>
<span class="n">app</span><span class="p">.</span><span class="n">config_from_object</span><span class="p">(</span><span class="s">"celery_config"</span><span class="p">)</span>

<span class="c1"># task 정의
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">task</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># task 비동기 호출
</span><span class="n">task</span> <span class="o">=</span> <span class="n">add</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<p>celery는 task queue를 사용하고, 이런 식으로 python으로 정의해놓은 함수를 이용해 쉽게 task를 정의 및 호출이 가능하다는 것이 장점이다.</p>

<h2 id="spring-boot에서-celery로-작업-넘기기">spring boot에서 celery로 작업 넘기기</h2>
<p><img src="/assets/images/Voice_Pocket/2-1.png" alt="image" width="60%" height="60%" /><br />
단순할 줄 알았는데, 생각보다 많은 삽질을 했다.</p>

<p>처음에는 <code class="language-plaintext highlighter-rouge">spring boot</code>에서 해당 queue에 json 형식으로 인자를 주고, 그 인자를 받아 pasing하는 task를 정의하려고 했으나, 생각해보니 task를 정의한다고 해도 그걸 어디서 호출할 것인지도 모호했고,</p>

<p>그냥 celery queue에 message를 실어주면, 알아서 worker가 수행해주지 않을까 싶었는데,<br />
queue에 실리는 task에는 일정 형식이 필요했고, 그게 맞지 않으면, worker가 그냥 message queue에서 해당 message를 삭제해버렸다.</p>

<p>관련해서 이것저것 찾아보다가 <code class="language-plaintext highlighter-rouge">medium</code>에서 해답을 얻을 수 있었다.</p>

<h2 id="celery-bootsteps-사용하기">celery bootsteps 사용하기</h2>
<blockquote>
  <p>You may want to embed custom Kombu consumers to manually process your messages.<br />
요약하자면 ‘사용자가 custom한 message consumer를 추가할 수 있다.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis</span><span class="p">,</span> <span class="n">json</span>

<span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">Celery</span>
<span class="kn">from</span> <span class="nn">celery</span> <span class="kn">import</span> <span class="n">bootsteps</span>
<span class="kn">from</span> <span class="nn">kombu</span> <span class="kn">import</span> <span class="n">Consumer</span><span class="p">,</span> <span class="n">Exchange</span><span class="p">,</span> <span class="n">Queue</span>

<span class="n">rd</span> <span class="o">=</span> <span class="n">redis</span><span class="p">.</span><span class="n">Redis</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">'host_name'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">port_num</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="n">db_num</span><span class="p">)</span>

<span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="s">"queue_name"</span><span class="p">,</span> <span class="n">Exchange</span><span class="p">(</span><span class="s">"exchange_name"</span><span class="p">),</span> <span class="s">"key_name"</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Celery</span><span class="p">()</span>
<span class="n">app</span><span class="p">.</span><span class="n">config_from_object</span><span class="p">(</span><span class="s">"celery_config"</span><span class="p">)</span>

<span class="c1"># TTS 정의
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">task</span>
<span class="k">def</span> <span class="nf">text_to_speech</span><span class="p">(</span><span class="n">uuid</span><span class="p">,</span> <span class="n">email</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">tts_process</span> <span class="kn">import</span> <span class="n">add_synth</span><span class="p">,</span> <span class="n">is_set</span><span class="p">,</span> <span class="n">make_tts</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_set</span><span class="p">(</span><span class="n">email</span><span class="p">):</span>
        <span class="n">add_synth</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>

    <span class="n">make_tts</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">email</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="n">uuid</span><span class="si">}</span><span class="s">.wav"</span>


<span class="c1"># Decalring the general input message handler
</span><span class="k">class</span> <span class="nc">InputMessageHandler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">"type"</span><span class="p">]</span>
        
        <span class="c1"># if you want to accept only specific type of message, you need below
</span>        <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="s">"ETL"</span><span class="p">:</span>
            <span class="n">ETLMessageHandler</span><span class="p">().</span><span class="n">handle</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        
        <span class="c1"># if body is json type, you need below
</span>        <span class="s">'''
        body_json = json.loads(body)  
        _type = body_json["type"]

        if _type == "ETL":
            ETLMessageHandler().handle(body_json)
        '''</span>


<span class="c1"># Declaring the ETL message handler
</span><span class="k">class</span> <span class="nc">ETLMessageHandler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Working on ETL for message: </span><span class="si">{</span><span class="n">body</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="c1"># TODO: Calling out your Celery tasks here
</span>        <span class="n">_uuid</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">"uuid"</span><span class="p">]</span>
        <span class="n">_email</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">"email"</span><span class="p">]</span>
        <span class="n">_text</span> <span class="o">=</span> <span class="n">body</span><span class="p">[</span><span class="s">"text"</span><span class="p">]</span>
        
        <span class="c1"># 정의한 task를 호출
</span>        <span class="n">task</span> <span class="o">=</span> <span class="n">text_to_speech</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="n">_uuid</span><span class="p">,</span> <span class="n">_email</span><span class="p">,</span> <span class="n">_text</span><span class="p">)</span>
        <span class="n">_task_json</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">({</span><span class="s">"task_id"</span><span class="p">:</span><span class="n">task</span><span class="p">.</span><span class="nb">id</span><span class="p">})</span>
        <span class="n">rd</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="n">_uuid</span><span class="p">,</span> <span class="n">_task_json</span><span class="p">)</span>


<span class="c1"># Declaring the bootstep for our purposes
</span><span class="k">class</span> <span class="nc">InputMessageConsumerStep</span><span class="p">(</span><span class="n">bootsteps</span><span class="p">.</span><span class="n">ConsumerStep</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_consumers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Consumer</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span>
                         <span class="n">queues</span><span class="o">=</span><span class="p">[</span><span class="n">queue</span><span class="p">],</span>
                         <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">handle_message</span><span class="p">],</span>
                         <span class="n">accept</span><span class="o">=</span><span class="p">[</span><span class="s">"json"</span><span class="p">])]</span>

    <span class="k">def</span> <span class="nf">handle_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">InputMessageHandler</span><span class="p">().</span><span class="n">handle</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="n">message</span><span class="p">.</span><span class="n">ack</span><span class="p">()</span>


<span class="n">app</span><span class="p">.</span><span class="n">steps</span><span class="p">[</span><span class="s">"consumer"</span><span class="p">].</span><span class="n">add</span><span class="p">(</span><span class="n">InputMessageConsumerStep</span><span class="p">)</span>
</code></pre></div></div>

<p>rabbitMQ 브로커에 kombu로 만든 queue를 얹어놓고, 거기에 spring boot에서 message를 publish하는 전략이다.<br />
body에서 필요한 인자들을 뽑아내, handle 메소드 안 쪽에서 미리 정의해놓은 celery task를 호출하는 방식으로 이루어진다.</p>

<p>개인적으로 느끼기에 많이 특이한 방식이기도 하고, ai 관련 라이브러리들은 보통 python으로 많이 짜여있어서,<br />
서버는 서버 따로, ai 관련 작업은 해당 작업 따로 관리하고자 할 때 유용하게 사용할 수 있을 것 같아 따로 정리해두었다.</p>

<p>혹시 비슷한 작업을 하고자한다면 참고하는 것도 좋을 것 같다 :)<br />
<a href="https://github.com/hi-june/boot_rabbit_celery">https://github.com/hi-june/boot_rabbit_celery</a> [Spring boot + RabbitMQ + Celery demo project]</p>

<h2 id="reference">Reference</h2>
<p>1) <a href="https://medium.com/python4you/calling-celery-tasks-not-from-python-699bd635d317">https://medium.com/python4you/calling-celery-tasks-not-from-python-699bd635d317</a> [Calling Celery Tasks not from Python]</p>]]></content><author><name>hi~ June!!</name></author><category term="Voice_Pocket" /><category term="Info" /><summary type="html"><![CDATA[Voice Pocket의 프로젝트]]></summary></entry><entry><title type="html">[Voice Pocket] 프로젝트 소개</title><link href="http://localhost:4000/voice_pocket/Voice_Pocket01/" rel="alternate" type="text/html" title="[Voice Pocket] 프로젝트 소개" /><published>2023-05-01T00:00:00+09:00</published><updated>2023-05-03T00:00:00+09:00</updated><id>http://localhost:4000/voice_pocket/Voice_Pocket01</id><content type="html" xml:base="http://localhost:4000/voice_pocket/Voice_Pocket01/"><![CDATA[<h2 id="개요">개요</h2>
<p>이전에 진행했던 Team_ForV의 프로젝트가 끝나고 못내 아쉬운 부분들이 있었다.<br />
사람의 목소리를 학습시켜 TTS 서비스를 만들 수 있다는 것은 꽤 흥미로운 주제라고 생각했고,<br />
이 주제를 좀 더 완성도 있는 프로젝트로 발전시키고 싶다는 생각을 했다.</p>

<p>따라서, 기존의 문제점들을 좀 더 보완하고, 기능들을 추가하여 새로운 프로젝트를 구상하게 되었다.</p>

<h2 id="voice-pocket">Voice Pocket..!</h2>
<p>개인적으로 요즘 웹 서비스보다는 앱 서비스를 더 많이 이용하기도 하고, 해당 주제도 웹 보다는 앱 서비스가 더 알맞을 것이라 생각하여<br />
새로운 프로젝트는 <code class="language-plaintext highlighter-rouge">Flutter</code>로 진행하게 되었다.</p>

<p><img src="/assets/images/Voice_Pocket/1-1.jpg" alt="image" width="60%" height="60%" /><br /></p>

<p>예전에 유튜브를 보다가 돌아가신 아버지의 목소리를 복원하여 가족들에게 추억을 선물해주었던 스토리를 본 적이 있다.</p>

<blockquote>
  <p>사람 목소리의 특성 자체를 보관해두고, 생각나는 순간마다 꺼내볼 수 있다면 좋지 않을까</p>
</blockquote>

<p>사랑하는 사람의 목소리를 듣는 것만으로도 큰 힘이 되는 순간들이 있다.<br />
하지만, 여러 상황들로 인해 그것조차 힘들어질 수도 있다.<br />
애초에 우리가 추억을 남기기 위해 사진을 저장하듯이 개인의 목소리 자체도 저장해둘 수 있고, 또 그것으로 힘이 되는 말을 들을 수 있다면 좋겠다는 생각에 이 프로젝트를 시작하게 되었다.</p>

<h2 id="이전-프로젝트에서-보완한-점">이전 프로젝트에서 보완한 점</h2>
<p>이전에 진행했던 <code class="language-plaintext highlighter-rouge">Team_ForV</code>에서 많은 것들을 추가했고, 발전시켰다.</p>

<ol>
  <li>사용자가 직접 자신의 목소리를 만들 수 있도록 구성했다.</li>
  <li>서로 친구를 맺은 관계라면, 서로의 목소리로 TTS(Text To Speech)를 사용할 수 있도록 구성했다.</li>
  <li>음성 합성 속도를 많이 개선시켰다.</li>
  <li>음성 파일 및 모델 파일로 인한 서버의 메모리 문제도 개선되었다.</li>
</ol>

<h2 id="앞으로의-포스팅-예고">앞으로의 포스팅 예고!</h2>
<p>이전 프로젝트와 비교하여 개선된 부분들에 대해 중점적으로 다뤄볼 예정이다.<br />
프로젝트를 진행하면서 중간중간에 맞이했던 이슈들, 고민들 그리고 그것들을 어떻게 해결했는지에 대해 정리할 예정이다.</p>

<p>(23.05.03 게시일 기준 아직 진행중인 프로젝트)<br />
<img src="/assets/images/Voice_Pocket/1-2.png" alt="image" /><br /></p>]]></content><author><name>hi~ June!!</name></author><category term="Voice_Pocket" /><category term="Info" /><summary type="html"><![CDATA[Voice Pocket의 프로젝트]]></summary></entry><entry><title type="html">[7569] 토마토</title><link href="http://localhost:4000/boj/7569/" rel="alternate" type="text/html" title="[7569] 토마토" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/7569</id><content type="html" xml:base="http://localhost:4000/boj/7569/"><![CDATA[<h2 id="gold-v-토마토---7569">[Gold V] 토마토 - 7569</h2>

<p><a href="https://www.acmicpc.net/problem/7569">문제 링크</a></p>

<h3 id="성능-요약">성능 요약</h3>

<p>메모리: 119348 KB, 시간: 748 ms</p>

<h3 id="분류">분류</h3>

<p>너비 우선 탐색, 그래프 이론, 그래프 탐색</p>

<h3 id="문제-설명">문제 설명</h3>

<p>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/c3f3343d-c291-40a9-9fe3-59f792a8cae9/-/preview/" style="width: 201px; height: 252px;" /></p>

<p>창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.</p>

<p>토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.</p>

<h3 id="입력">입력</h3>

<p>첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.</p>

<p>토마토가 하나 이상 있는 경우만 입력으로 주어진다.</p>

<h3 id="출력">출력</h3>

<p>여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</p>

<h2 id="아이디어">아이디어</h2>
<p>3차원 행렬을 다루는 것이 익숙치 않아 시간이 좀 걸렸었던 문제였다.<br />
x, y, z를 z, y, x 순으로 초기화해야한다는 것을 기억하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][][]</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">z</span><span class="o">][</span><span class="n">y</span><span class="o">][</span><span class="n">x</span><span class="o">];</span>
</code></pre></div></div>

<h2 id="답안코드">답안코드</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">z</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">z</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getX</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getY</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">y</span><span class="o">;</span> <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getZ</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">z</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>   <span class="c1">// x</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>   <span class="c1">// y</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>   <span class="c1">// z</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">ripenTomato</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>   <span class="c1">// 익은 토마토</span>
        <span class="kt">int</span> <span class="n">unRipenTomato</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// 안 익은 토마토</span>
        <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>    <span class="c1">// 소요 날짜</span>

        <span class="c1">// initialize box</span>
        <span class="kt">int</span><span class="o">[][][]</span> <span class="n">box</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">box</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">l</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    
                    <span class="k">if</span> <span class="o">(</span><span class="n">box</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">unRipenTomato</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// 안 익은 토마토</span>
                    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">box</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">][</span><span class="n">l</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">ripenTomato</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>   <span class="c1">// 익은 토마토</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 이동: 상, 하, 좌, 우, 전, 후</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dz</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>

        <span class="c1">// bfs(인접 토마토 익히기)</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">unRipenTomato</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ripenTomato</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">todayRipenTomato</span> <span class="o">=</span> <span class="n">ripenTomato</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>  <span class="c1">// '오늘' 익어있는 토마토</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">todayRipenTomato</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">ripenTomato</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">getZ</span><span class="o">();</span>

                <span class="c1">// 6방향으로 토마토 익히기</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">movedX</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">movedY</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">movedZ</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">dz</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>

                    <span class="c1">// 범위를 벗어나거나 안 익은 토마토가 아닌 경우는 제외</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">movedX</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">movedX</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="o">||</span> <span class="n">movedY</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">movedY</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">movedZ</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">movedZ</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">||</span> <span class="n">box</span><span class="o">[</span><span class="n">movedZ</span><span class="o">][</span><span class="n">movedY</span><span class="o">][</span><span class="n">movedX</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>

                    <span class="n">unRipenTomato</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 안 익은 토마토 개수 줄이기</span>
                    <span class="n">box</span><span class="o">[</span><span class="n">movedZ</span><span class="o">][</span><span class="n">movedY</span><span class="o">][</span><span class="n">movedX</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>    <span class="c1">// 토마토 익히기</span>
                    <span class="n">ripenTomato</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">movedX</span><span class="o">,</span> <span class="n">movedY</span><span class="o">,</span> <span class="n">movedZ</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="n">day</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">unRipenTomato</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">day</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>hi~ June!!</name></author><category term="BOJ" /><category term="java" /><category term="bfs" /><summary type="html"><![CDATA[백준 문제 풀이]]></summary></entry><entry><title type="html">[2644] 촌수계산</title><link href="http://localhost:4000/boj/2644/" rel="alternate" type="text/html" title="[2644] 촌수계산" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-20T00:00:00+09:00</updated><id>http://localhost:4000/boj/2644</id><content type="html" xml:base="http://localhost:4000/boj/2644/"><![CDATA[<h2 id="silver-ii-촌수계산---2644">[Silver II] 촌수계산 - 2644</h2>

<p><a href="https://www.acmicpc.net/problem/2644">문제 링크</a></p>

<h3 id="성능-요약">성능 요약</h3>

<p>메모리: 14252 KB, 시간: 132 ms</p>

<h3 id="분류">분류</h3>

<p>그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색</p>

<h3 id="문제-설명">문제 설명</h3>

<p>우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.</p>

<p>여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.</p>

<h3 id="입력">입력</h3>

<p>사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.</p>

<p>각 사람의 부모는 최대 한 명만 주어진다.</p>

<h3 id="출력">출력</h3>

<p>입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.</p>

<h2 id="아이디어">아이디어</h2>
<p>촌수가 깊어질 수록 depth를 증가시켜가며 풀었던 문제이다.<br />
처음에는 depth 변수를 어떻게 두어야할 지 고민했는데, 함수의 입력인자로 둔 뒤 깊어질 때마다 1 증가시키며 다음 함수에 전달해주는 방식으로 해결했다.<br />
함수를 recursive하게 호출하고 있기 때문에 answer 변수는 static하게 처리했다.</p>

<h2 id="답안코드">답안코드</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>

        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">target1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">target2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="kt">int</span> <span class="n">relation</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">relation</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
            <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">y</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="n">dfs</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">target1</span><span class="o">,</span> <span class="n">target2</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">target1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">node</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target1</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">target2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">answer</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">visited</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="n">target2</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>hi~ June!!</name></author><category term="BOJ" /><category term="java" /><category term="dfs" /><summary type="html"><![CDATA[백준 문제 풀이]]></summary></entry></feed>